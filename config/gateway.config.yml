http:
  port: 8080
admin:
  port: 9876
  host: localhost
apiEndpoints:
  # Gateway self health check
  healthApi:
    paths: ["/api/health"]

  # Backend Microservices
  authApi:
    paths: ["/api/auth/*", "/api/auth/"]
  userApi:
    paths: ["/api/users/*", "/api/users/"]
  postApi:
    paths: ["/api/posts/*", "/api/posts/"]
  replyApi:
    paths: ["/api/replies/*", "/api/replies/"]
  messageApi:
    paths: ["/api/messages/*", "/api/messages/"]
  historyApi:
    paths: ["/api/history/*", "/api/history/"]
  fileApi:
    paths: ["/api/files/*", "/api/files/"]
  apiFallback:
    paths: ["/api/*", "/api/"]
  # Public (Frontend -> Gateway)
  # This must be the last
  # Because it matches all paths
  page:
    paths: ["/*"]
  
policies:
  - cors
  - proxy
  - jwt
  - log
  - request-transformer
  - terminate

serviceEndpoints:
  # display the frontend page
  pageService:
    url: "http://localhost:3000"
  # gateway self
  gatewaySelf:
    url: "http://localhost:8080"
  # microservices
  authService:
    url: "http://localhost:8001"
  userService:
    url: "http://localhost:8002"
  postReplyService:
    url: "http://localhost:8003"
  messageService:
    url: "http://localhost:8004"
  historyService:
    url: "http://localhost:8005"
  fileService:
    url: "http://localhost:8006"

pipelines:
  # Direct Health Check
  healthPipeline:
    apiEndpoints:
      - healthApi
    policies:
      - terminate:
          - action:
              statusCode: 200
              message: "OK"

  # SECURE PIPELINE (Shared Auth Logic)
  protectedPipeline:
    apiEndpoints:
      - userApi
      - postApi
      - replyApi
      - messageApi
      - historyApi
      - fileApi
      - apiFallback
    policies:
      - log:
          - action:
              message: "Authenticated request to ${req.url}"

      # TODO: enable JWT validation once cookie extraction is fixed
      # The following two steps are to extract JWT from Cookie and validate it

      # # Step 1: Extract Cookie and put into Authorization header
      # - request-transformer:
      #     - action:
      #         headers:
      #           add:
      #             authorization: >
      #               req.headers.cookie && req.headers.cookie.includes('token=') 
      #               ? req.headers.cookie.split('; ').find(row => row.startsWith('token=')).split('=')[1] 
      #               : ''
      # # Step 2: Validate JWT
      # - jwt:
      #     - action:
      #         secretOrPublicKey: ${ACCESS_TOKEN_SECRET}
      #         credentialsRequired: true
      #         tokenProperty: 'authorization'
      #         algorithm: 'HS256'

      # Step 3: Inject UserID for Microservices
      # UserID is stored in X-User-Context as a JSON string
      - request-transformer:
          - action:
              headers:
                add:
                  # X-User-Context is a JSON string containing user info
                  # read X-User-Id from the X-User-Context
                  x-user-id: >
                    req.headers['x-user-context'] ? JSON.parse(req.headers['x-user-context']).userId : ''
            
      # Step 4: Conditional Proxy (Route to correct microservice)
      - proxy:
          - condition:
              name: pathMatch
              pattern: "/api/users(.*)"
            action:
              serviceEndpoint: userService
              changeOrigin: true
          - condition:
              name: pathMatch
              pattern: "/api/posts(.*)"
            action:
              serviceEndpoint: postReplyService
              changeOrigin: true
          - condition:
              name: pathMatch
              pattern: "/api/replies(.*)"
            action:
              serviceEndpoint: postReplyService
              changeOrigin: true
          - condition:
              name: pathMatch
              pattern: "/api/messages(.*)"
            action:
              serviceEndpoint: messageService
              changeOrigin: true
          - condition:
              name: pathMatch
              pattern: "/api/history(.*)"
            action:
              serviceEndpoint: historyService
              changeOrigin: true
          - condition:
              name: pathMatch
              pattern: "/api/files(.*)"
            action:
              serviceEndpoint: fileService
              changeOrigin: true

  # Frontend Page (No Auth Required)
  # We use CSR so no need to protect the page route
  pagePipeline:
    apiEndpoints:
      - page
    policies:
      - proxy:
          - action:
              serviceEndpoint: pageService
              changeOrigin: true